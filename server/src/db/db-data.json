{
  "users": [
    {
      "id": 1,
      "username": "Kent C. Dodds",
      "passwordHash": "$2b$10$3hjkzdg2VjtwsIDcWQludebM.jUfq6vSicB4vwna78JW3UqtwSi06",
      "avatarUrl": "https://cdn-images-1.medium.com/fit/c/120/120/1*9ZtET_L1852yXaDZJUo9CQ.png",
      "bio": "Making software development more accessible ¬∑ Husband, Father, Mormon, Teacher, OSS, GDE, @TC39 ¬∑ @PayPalEng @eggheadio @FrontendMasters @JavaScriptAir ¬∑ #JS"
    },
    {
      "id": 2,
      "username": "john",
      "passwordHash": "$2b$10$eGtavxWlp1PwJ6VpZ4cTieDki738YPmDLndi1NckBkfEKrZ136jSS",
      "avatarUrl": "https://cdn-images-1.medium.com/fit/c/120/120/0*cmAOkoH29zoIVIBT",
      "bio": ""
    }
  ],
  "blogs": [
    {
      "id": 1,
      "userId": 1,
      "name": "Kent C. Dodds",
      "description": "Let‚Äôs make awesome with JavaScript (Photo by Luca Bravo on Unsplash)"
    }
  ],
  "posts": [
    {
      "id": 1,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it‚Äôs good, why it‚Äôs bad, and how to avoid common problems with it.",
      "contentMarkup": "<p><b>NOTE: This is a cross-post from my <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</b></p><p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as ‚Äúthreading‚Äù), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</pre><p>Let‚Äôs refactor this into two components now:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        The button is {on ? 'on' : 'off'}<br>      &lt;/div&gt;<br>      &lt;button onClick={onToggle}&gt;<br>        Toggle<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre><p>Simple enough, the <strike>Switch</strike> needs a reference to the <strike>toggle</strike> and <strike>on</strike> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;SwitchMessage on={on} /&gt;<br>      &lt;SwitchButton onToggle={onToggle} /&gt;<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchMessage({on}) {<br>  return (<br>    &lt;div&gt;<br>      The button is {on ? 'on' : 'off'}<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchButton({onToggle}) {<br>  return (<br>    &lt;button onClick={onToggle}&gt;<br>      Toggle<br>    &lt;/button&gt;<br>  )<br>}</pre><p>This is prop drilling. To get the <strike>on</strike> state and <strike>toggle</strike> handler to the right places, we have to drill (or thread) props through the <strike>Switch</strike> component. The <strike>Switch</strike> component itself doesn't actually need those values to function, but we have to accept and forward those props because its children need them.</p><h3>Why is prop drilling good?</h3><p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <strike>$scope</strike> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <b>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</b></p><p>One reason we prefer ESModules over global variables is because it allows us to be more explicit about where our values are used, making it much easier to track values and eases the process determining what impact your changes will have on the rest of the application.</p><p>Prop drilling at its most basic level is simply explicitly passing values throughout the view of your application. This is great because if you were coming to the <strike>Toggle</strike> above and decided you want to refactor the <strike>on</strike> state to be an enum, you'd easily be able to track all places it's used by following the code statically (without having to run it) and make that update. The key here is explicitness over implicitness.</p><h3>What problems can prop drilling cause?</h3><p>In our contrived example above, there‚Äôs absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It‚Äôs not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p><ul><li>Refactor the shape of some data (ie: <strike>{user: {name: 'Joe West'}}</strike> -&gt; <strike>{user: {firstName: 'Joe', lastName: 'West'}}</strike>).</li><li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they‚Äôre no longer needed.</li><li>Under-forwarding props + abusing <strike>defaultProps</strike> so you're not made aware of missing props (also due to (re)moving a component).</li><li>Renaming props halfway through (ie <strike>&lt;Toggle on={this.state.on} /&gt;</strike> renders <strike>&lt;Switch toggleIsOn={on} /&gt;</strike>) making keeping track of that in your brain difficult.</li></ul><p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p><h3>How can we avoid problems with prop drilling?</h3><p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!<br></p><blockquote>Fun fact, there‚Äôs nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you‚Äôd have one giant render method‚Ä¶ I am not advocating this though‚Ä¶ Just something to think about :)</blockquote><p>Another thing you can can do to mitigate the effects of prop-drilling is avoid using defaultProps for anything that's a required prop. Using a defaultProp for something that's actually required for the component to function properly is just hiding important errors and making things fail silently. So only use defaultProps for things that are not required.<br></p><p>Keep state as close to where it‚Äôs relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: <a href=\"https://blog.kentcdodds.com/application-state-management-66de608ccb24\" target=\"_blank\" rel=\"noopener noreferrer\">Application State Management</a>.<br></p><p>Use React‚Äôs new Context API for things that are truly necessary deep in the react tree. They don‚Äôt have to be things you need everywhere in the application (you can render a provider anywhere in the app). This can really help avoid some issues with prop drilling. It‚Äôs been noted that context is kinda taking us back to the days of global variables. The difference is that because of the way the API was designed, you can still statically find the source of the context as well as any consumers with relative ease.<br></p><h3>Conclusion</h3><p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 2,
      "blogId": 1,
      "userId": 1,
      "title": "Write your own code transform for fun and profit",
      "subTitle": "How to write your own code macro with babel-plugin-macros üé£",
      "contentMarkup": "<p>If you haven‚Äôt heard, <a href=\"https://github.com/kentcdodds/babel-plugin-macros\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-plugin-macros</strike></a> \"enables zero-config, importable babel plugins.\" A few months ago, I published a blog post about it on the official babel blog: <a href=\"https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros\" target=\"_blank\" rel=\"noopener noreferrer\">\"Zero-config code transformation with babel-plugin-macros\"</a>.<br></p><p>Since then, there have been a few exciting developments:<br></p><ol><li><b>You can use it with a create-react-app application</b> (v2 beta) because it‚Äôs now included by default in the beta version of <a href=\"https://www.npmjs.com/package/babel-preset-react-app\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-preset-react-app</strike></a> (which is what create-react-app v2 beta is using!)<br></li><li>It was added as an optional transform to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a> by <a href=\"https://twitter.com/FWeinb\" target=\"_blank\" rel=\"noopener noreferrer\">@FWeinb</a></li></ol><p>Up until now, only early adopters have tried to write a macro, though there are a fair amount of people using the growing list of <a href=\"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/macros.md\" target=\"_blank\" rel=\"noopener noreferrer\">existing macros</a>. There are tons of awesome things you can do with <strike>babel-plugin-macros</strike>, and I want to dedicate this newsletter to showing you how to get started playing around with writing your own.</p><p>Let‚Äôs start off with a contrived macro that can split a string of text and replace every space with <strike>üê∂</strike>. We'll call it <strike>gemmafy</strike> because my dog's name is \"Gemma.\" Woof!<br></p><ol><li>Go to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a><br></li><li>Make sure the language is set to <strike>JavaScript</strike><br></li><li>Make sure the parser is set to <strike>babylon7</strike><br></li><li>Enable the transform and set it to <strike>babel-macros</strike> (or <strike>babel-plugin-macros</strike> as soon as this is merged)<br></li></ol><p>Then copy/paste this in the source (top left) code panel:<br></p><pre>import gemmafy from 'gemmafy.macro'\n<br>console.log(gemmafy('hello world'))</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(gemmafyMacro)\n<br>function gemmafyMacro({ references, state, babel }) {<br>  references.default.forEach(referencePath =&gt; {<br>    const [firstArgumentPath] = referencePath.parentPath.get('arguments')<br>    const stringValue = firstArgumentPath.node.value<br>    const gemmafied = stringValue.split(' ').join(' üê∂ ')<br>    const gemmafyFunctionCallPath = firstArgumentPath.parentPath<br>    const gemmafiedStringLiteralNode = babel.types.stringLiteral(gemmafied)<br>    gemmafyFunctionCallPath.replaceWith(gemmafiedStringLiteralNode)<br>  })<br>}</pre><blockquote>Alternatively, you can <a href=\"https://astexplorer.net/#/gist/b93bac9c0cdeddd6a1888ad7e82f4cbe/e84e9536951bd0d6fec76b9b50e5f6b01539a4c5\" target=\"_blank\" rel=\"noopener noreferrer\">open this</a></blockquote><p>TADA üéâ! You‚Äôve written your (probably) very first babel plugin via a macro!</p><p>Here‚Äôs the output that you should be seeing (in the bottom right panel):</p><pre>console.log(\"hello üê∂ world\")</pre><p>You‚Äôll notice that <strike>babel-plugin-macros</strike> will take care of removing the import at the top of the file for you, and our macro replaced the <strike>gemmafy</strike> call with the string.</p><p>So here‚Äôs your challenge. Try to add this:<br></p><pre>console.log(gemmafy('hello world', 'world goodbye'))</pre><p>Right now that‚Äôll transpile to:</p><pre>console.log(\"hello üê∂ world\")</pre><p>Your job is to make it do this instead:</p><pre>console.log(\"hello üê∂ world\", \"goodbye üê∂ world\")</pre><p>From there, you can play around with it and do a lot of fun things!</p><p>If you want to see more of the capabilities, then copy this in the source (top left):</p><pre>import myMacro, { JSXMacro } from 'AnyNameThatEndsIn.macro';<br>// (note: in reality, the AnyNameThatEndsIn.macro should be the name of your package<br>// for example: `codegen.macro`)<br>const functionCall = myMacro('Awesome');<br>const jsx = &lt;JSXMacro cool=\"right!?\"&gt;Hi!&lt;/JSXMacro&gt;;<br>const templateLiteral = myMacro`hi ${'there'}`;<br>literallyAnythingWorks(myMacro);</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(myMacro);<br>function myMacro({ references, state, babel }) {<br>  // `state` is the second argument you're passed to a visitor in a<br>  // normal babel plugin. `babel` is the `@babel/core` module.<br>  // do whatever you like to the AST paths you find in `references`.<br>  // open up the console to see what's logged and start playing around!<br>// references.default refers to the default import (`myMacro` above)<br>  // references.JSXMacro refers to the named import of `JSXMacro`<br>  const { JSXMacro = [], default: defaultImport = [] } = references;<br>defaultImport.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"TaggedTemplateExpression\") {<br>      console.log(\"template literal contents\", referencePath.parentPath.get(\"quasi\"));<br>    } else if (referencePath.parentPath.type === \"CallExpression\") {<br>      if (referencePath === referencePath.parentPath.get(\"callee\")) {<br>        console.log(<br>          \"function call arguments (as callee)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      } else if (referencePath.parentPath.get(\"arguments\").includes(referencePath)) {<br>        console.log(<br>          \"function call arguments (as argument)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      }<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>JSXMacro.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"JSXOpeningElement\") {<br>      console.log(\"jsx props\", {<br>        attributes: referencePath.parentPath.get(\"attributes\"),<br>        children: referencePath.parentPath.parentPath.get(\"children\")<br>      });<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>}</pre><p>Next, open up your developer console and check out the console logs. Have fun with that!</p><blockquote>Alternatively, you can just <a href=\"https://astexplorer.net/#/gist/bee085792657d68468353b868a34a2a6/97e09889c85de1f839717a8b351ad4ec1376501a\" target=\"_blank\" rel=\"noopener noreferrer\">go here</a></blockquote><h3>Conclusion</h3><p>I think there are a LOT of really cool places we can go with this technology. I didn‚Äôt spend any time in this newsletter talking about the why behind macros or giving you ideas. I‚Äôll link to some resources for ideas below. The basic idea is if there‚Äôs a way that you can pre-compile some of your operations, then you can improve runtime performance/bundle size of your application. In addition, this allows you to do some things at build time when you have access to the file system. The possibilities are really endless and we‚Äôre just getting started! Enjoy!</p>",
      "isLargePreview": false,
      "imgDescriptor": "1*mJEOJUxW51Vh-Y7cihnS0w.jpeg",
      "date": "Jun 4",
      "readTimeEstimate": "5 min"
    },
    {
      "id": 3,
      "blogId": 1,
      "userId": 1,
      "title": "How I learn an Open Source Codebase",
      "subTitle": "What I do to learn and understand an open source project to which I want to contribute.",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">my newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</strong></p>\n  <p>Participating in open source has been awesome for me. It has made me and the stuff I make better. A common question that I get from folks is how to go about learning an open source codebase and understand other‚Äôs code.<br></p><p>In my blog post <a href=\"https://medium.com/@kentcdodds/open-source-stamina-dafd063f9932\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúOpen Source Stamina‚Äù</a>, I make an important observation:</p><blockquote><b>You contribute best to something you use regularly.</b></blockquote>\n\n  <p>So while it can be a lot of fun to just jump into any open source project and help out. Sustainable contributions are best found in projects that you use on a regular basis. You have a better understanding of the use cases of the code which will help you understand the code better.</p><h3>Some steps</h3>\n  <p>Here‚Äôs a sequence of events I go through when I‚Äôm trying to learn or contribute to an open source project:</p><h4>Contributing Guidelines</h4><p>Look at the contributing guidelines first! This can be found in the <strike>README.md</strike> or a <strike>CONTRIBUTING.md</strike> file in the project. If it doesn‚Äôt exist, then file an issue and ask the maintainer to either make one or give you an idea of what they expect out of contributions.</p><h4>Project setup</h4><p>When you set up the project on your computer, make sure that you first install the dependencies and that the tests pass (if there are any). For JavaScript projects, you can mostly do:</p><ol><li>clone repo<br></li><li><strike>npm install</strike><br></li><li><strike>npm test</strike><br></li></ol><p>If all that works then you‚Äôre ready to go. The last thing you want to do is clone a repo with failing tests, make your change, and think that your change is the reason the tests are failing! This has happened to me :-(</p><h4>Follow the code</h4><p>Next, I try to follow the code in my head starting at the entry point where I‚Äôm interested in (like a function call, or a CLI with a certain argument). This can be intimidating for bigger projects, but it‚Äôs not as bad as you might think.</p><p>In my blogpost <a href=\"https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúWhat open source project should I contribute to?‚Äù</a> I talk a little bit about how to find where the code is for a specific API.</p><h4>Break things</h4><p>Reading and running the tests is also useful. Breaking things can also be a helpful way to learn a codebase.</p><h4>Log and step through</h4><p>It‚Äôs a tried and true debugging mechanism: <strike>console.log</strike> is a great way to learn a codebase. üëç Even better if you can run it in the browser DevTools that‚Äôs also great. <a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\" target=\"_blank\" rel=\"noopener noreferrer\">Read more about NodeJS debugging in Chrome DevTools</a>.</p><p>One other thing you might try is running the project‚Äôs code in the context of your application. I talk about this a fair amount in my blog post from a few weeks ago <a href=\"https://blog.kentcdodds.com/spelunking-in-node-modules-bf165af19968\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúSpelunking in node_modules üë∑‚Äù</a>.</p><h3>Conclusion</h3><p>Something else that I‚Äôve found helpful is to ask someone on the project to walk me through some part of the code. I try to make it worth their time by offering to record our conversation and make it publicly available. This is appealing to maintainers because having material out there for new contributors to watch is very helpful. Here are some examples:</p><ul><li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Why, What, and How of React Fiber with Dan Abramov and Andrew Clark</a><br></li><li><a href=\"https://www.youtube.com/watch?v=dRo_egw7tBc&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a><br></li><li><a href=\"https://www.youtube.com/watch?v=i31VtyJSM-I&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript &amp; React Testing with Jest</a><br></li><li><a href=\"https://www.youtube.com/watch?v=wUpPsEcGsg8&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Contributing to ReactJS</a><br></li></ul><p>I hope this is helpful! Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*NbePWo0hJrYA4mHeQBHmDw.jpeg",
      "date": "May 14",
      "readTimeEstimate": "4 min"
    },
    {
      "id": 4,
      "blogId": 1,
      "userId": 1,
      "title": "Dealing with FOMO",
      "subTitle": "What is ‚ÄúFear Of Missing Out‚Äù and how to deal with this natural unhealthy tendency.",
      "contentMarkup": "<p>If you‚Äôre not familiar with the acronym FOMO that‚Äôs totally fine (and also a tiny bit ironic). FOMO stands for ‚ÄúFear Of Missing Out.‚Äù You might feel this for example if you‚Äôre deciding whether to learn <a href=\"https://reasonml.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">ReasonML</a> or keep going deep into JavaScript (this happens to be something that I‚Äôm currently struggling with).</p><h3>What‚Äôs wrong with FOMO</h3><p>FOMO is paralyzing. I once entered a conversation with a man at a conference who was very concerned about which JavaScript framework to use for building applications. He asked me how I could possibly decide. I just said that I tried a few and chose one that I thought was pretty good and went with it.</p><p>He couldn‚Äôt grasp it at all and showed me a Google Spreadsheet he‚Äôd created that would probably take half a tree to print (a small tree probably). It had columns for every framework imaginable and rows for every conceivable feature. I‚Äôm telling you, this thing was HUGE.</p><p>Even with this exhaustive comparison, he still couldn‚Äôt decide. He was worried about making the wrong decision. We call this analysis paralysis and I actually mentioned to him that I thought he‚Äôd hit that point which he denied. Whether or not that really was the case, he was emotionally consumed by this decision.</p><h3>Where does FOMO come from?</h3><p>FOMO is entirely based on comparing one‚Äôs self with others. These kinds of comparisons are entirely unhealthy and insatiable. No matter how much knowledge or experience you gain, there will always be someone who has more and you will be left feeling inadequate.</p><p>The reason for this is we often make the mistake of thinking there are only two people in the world: You, and everyone else. While this entirely false, it‚Äôs an easy pit to fall into and leads to FOMO and feelings that we can never measure up to where everyone who is not us is at.</p><h3>How to manage</h3><p>Knowing that FOMO comes from the unhealthy tendency to compare ourselves to others, managing and gaining control of FOMO becomes a task of controlling that tendency. I‚Äôm still working on this myself, but I think a great first step is to be mindful of yourself and the thoughts you‚Äôre having about others and yourself. Try to catch yourself thinking thoughts like: ‚ÄúI‚Äôm better than them at x‚Äù or ‚ÄúWow, I‚Äôll never be that good at x as they are.‚Äù However true those thoughts are, they are not helpful or compassionate to yourself or others.</p><p>Instead, consciously train your brain to think things like: ‚ÄúHow can I help others learn what I know?‚Äù or ‚ÄúWow! That‚Äôs really cool that they‚Äôre so talented at that!‚Äù There‚Äôs nothing wrong with a healthy desire to learn more, and you can train your brain to think positively about your ability to improve. Changing the tone and attitude of your own self-talk can really make a positive impact of how you feel about yourself and others. You‚Äôll feel more motivated to improve and feel empowered to do so.</p><h3>Conclusion</h3><p>I think it‚Äôs really important for you to know that your brain is a muscle and you can exercise different parts of it. Try to exercise the parts of your brain that help you be more compassionate to yourself and others and you‚Äôll reduce your unhealthy FOMO and develop a healthy amount of MTBB (Motivation To Become Better‚Ä¶ I just made that up).</p><p>I hope that‚Äôs helpful to you. Like I said, this is something I‚Äôm actively working on in myself, I hope that together we can work on improving this aspect of ourselves and find more happiness in life :) Good luck!</p>",
      "isLargePreview": true,
      "imgDescriptor": "1*SI4Nd9m-LunZXicI_mE4gw.png",
      "date": "Jun 18",
      "readTimeEstimate": "4 min"
    },
    {
      "id": 5,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it‚Äôs good, why it‚Äôs bad, and how to avoid common problems with it.",
      "contentMarkup": "<p><b>NOTE: This is a cross-post from my <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</b></p><p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as ‚Äúthreading‚Äù), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</pre><p>Let‚Äôs refactor this into two components now:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        The button is {on ? 'on' : 'off'}<br>      &lt;/div&gt;<br>      &lt;button onClick={onToggle}&gt;<br>        Toggle<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre><p>Simple enough, the <strike>Switch</strike> needs a reference to the <strike>toggle</strike> and <strike>on</strike> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;SwitchMessage on={on} /&gt;<br>      &lt;SwitchButton onToggle={onToggle} /&gt;<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchMessage({on}) {<br>  return (<br>    &lt;div&gt;<br>      The button is {on ? 'on' : 'off'}<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchButton({onToggle}) {<br>  return (<br>    &lt;button onClick={onToggle}&gt;<br>      Toggle<br>    &lt;/button&gt;<br>  )<br>}</pre><p>This is prop drilling. To get the <strike>on</strike> state and <strike>toggle</strike> handler to the right places, we have to drill (or thread) props through the <strike>Switch</strike> component. The <strike>Switch</strike> component itself doesn't actually need those values to function, but we have to accept and forward those props because its children need them.</p><h3>Why is prop drilling good?</h3><p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <strike>$scope</strike> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <b>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</b></p><p>One reason we prefer ESModules over global variables is because it allows us to be more explicit about where our values are used, making it much easier to track values and eases the process determining what impact your changes will have on the rest of the application.</p><p>Prop drilling at its most basic level is simply explicitly passing values throughout the view of your application. This is great because if you were coming to the <strike>Toggle</strike> above and decided you want to refactor the <strike>on</strike> state to be an enum, you'd easily be able to track all places it's used by following the code statically (without having to run it) and make that update. The key here is explicitness over implicitness.</p><h3>What problems can prop drilling cause?</h3><p>In our contrived example above, there‚Äôs absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It‚Äôs not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p><ul><li>Refactor the shape of some data (ie: <strike>{user: {name: 'Joe West'}}</strike> -&gt; <strike>{user: {firstName: 'Joe', lastName: 'West'}}</strike>).</li><li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they‚Äôre no longer needed.</li><li>Under-forwarding props + abusing <strike>defaultProps</strike> so you're not made aware of missing props (also due to (re)moving a component).</li><li>Renaming props halfway through (ie <strike>&lt;Toggle on={this.state.on} /&gt;</strike> renders <strike>&lt;Switch toggleIsOn={on} /&gt;</strike>) making keeping track of that in your brain difficult.</li></ul><p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p><h3>How can we avoid problems with prop drilling?</h3><p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!<br></p><blockquote>Fun fact, there‚Äôs nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you‚Äôd have one giant render method‚Ä¶ I am not advocating this though‚Ä¶ Just something to think about :)</blockquote><p>Another thing you can can do to mitigate the effects of prop-drilling is avoid using defaultProps for anything that's a required prop. Using a defaultProp for something that's actually required for the component to function properly is just hiding important errors and making things fail silently. So only use defaultProps for things that are not required.<br></p><p>Keep state as close to where it‚Äôs relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: <a href=\"https://blog.kentcdodds.com/application-state-management-66de608ccb24\" target=\"_blank\" rel=\"noopener noreferrer\">Application State Management</a>.<br></p><p>Use React‚Äôs new Context API for things that are truly necessary deep in the react tree. They don‚Äôt have to be things you need everywhere in the application (you can render a provider anywhere in the app). This can really help avoid some issues with prop drilling. It‚Äôs been noted that context is kinda taking us back to the days of global variables. The difference is that because of the way the API was designed, you can still statically find the source of the context as well as any consumers with relative ease.<br></p><h3>Conclusion</h3><p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 6,
      "blogId": 1,
      "userId": 1,
      "title": "Write your own code transform for fun and profit",
      "subTitle": "How to write your own code macro with babel-plugin-macros üé£",
      "contentMarkup": "<p>If you haven‚Äôt heard, <a href=\"https://github.com/kentcdodds/babel-plugin-macros\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-plugin-macros</strike></a> \"enables zero-config, importable babel plugins.\" A few months ago, I published a blog post about it on the official babel blog: <a href=\"https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros\" target=\"_blank\" rel=\"noopener noreferrer\">\"Zero-config code transformation with babel-plugin-macros\"</a>.<br></p><p>Since then, there have been a few exciting developments:<br></p><ol><li><b>You can use it with a create-react-app application</b> (v2 beta) because it‚Äôs now included by default in the beta version of <a href=\"https://www.npmjs.com/package/babel-preset-react-app\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-preset-react-app</strike></a> (which is what create-react-app v2 beta is using!)<br></li><li>It was added as an optional transform to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a> by <a href=\"https://twitter.com/FWeinb\" target=\"_blank\" rel=\"noopener noreferrer\">@FWeinb</a></li></ol><p>Up until now, only early adopters have tried to write a macro, though there are a fair amount of people using the growing list of <a href=\"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/macros.md\" target=\"_blank\" rel=\"noopener noreferrer\">existing macros</a>. There are tons of awesome things you can do with <strike>babel-plugin-macros</strike>, and I want to dedicate this newsletter to showing you how to get started playing around with writing your own.</p><p>Let‚Äôs start off with a contrived macro that can split a string of text and replace every space with <strike>üê∂</strike>. We'll call it <strike>gemmafy</strike> because my dog's name is \"Gemma.\" Woof!<br></p><ol><li>Go to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a><br></li><li>Make sure the language is set to <strike>JavaScript</strike><br></li><li>Make sure the parser is set to <strike>babylon7</strike><br></li><li>Enable the transform and set it to <strike>babel-macros</strike> (or <strike>babel-plugin-macros</strike> as soon as this is merged)<br></li></ol><p>Then copy/paste this in the source (top left) code panel:<br></p><pre>import gemmafy from 'gemmafy.macro'\n<br>console.log(gemmafy('hello world'))</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(gemmafyMacro)\n<br>function gemmafyMacro({ references, state, babel }) {<br>  references.default.forEach(referencePath =&gt; {<br>    const [firstArgumentPath] = referencePath.parentPath.get('arguments')<br>    const stringValue = firstArgumentPath.node.value<br>    const gemmafied = stringValue.split(' ').join(' üê∂ ')<br>    const gemmafyFunctionCallPath = firstArgumentPath.parentPath<br>    const gemmafiedStringLiteralNode = babel.types.stringLiteral(gemmafied)<br>    gemmafyFunctionCallPath.replaceWith(gemmafiedStringLiteralNode)<br>  })<br>}</pre><blockquote>Alternatively, you can <a href=\"https://astexplorer.net/#/gist/b93bac9c0cdeddd6a1888ad7e82f4cbe/e84e9536951bd0d6fec76b9b50e5f6b01539a4c5\" target=\"_blank\" rel=\"noopener noreferrer\">open this</a></blockquote><p>TADA üéâ! You‚Äôve written your (probably) very first babel plugin via a macro!</p><p>Here‚Äôs the output that you should be seeing (in the bottom right panel):</p><pre>console.log(\"hello üê∂ world\")</pre><p>You‚Äôll notice that <strike>babel-plugin-macros</strike> will take care of removing the import at the top of the file for you, and our macro replaced the <strike>gemmafy</strike> call with the string.</p><p>So here‚Äôs your challenge. Try to add this:<br></p><pre>console.log(gemmafy('hello world', 'world goodbye'))</pre><p>Right now that‚Äôll transpile to:</p><pre>console.log(\"hello üê∂ world\")</pre><p>Your job is to make it do this instead:</p><pre>console.log(\"hello üê∂ world\", \"goodbye üê∂ world\")</pre><p>From there, you can play around with it and do a lot of fun things!</p><p>If you want to see more of the capabilities, then copy this in the source (top left):</p><pre>import myMacro, { JSXMacro } from 'AnyNameThatEndsIn.macro';<br>// (note: in reality, the AnyNameThatEndsIn.macro should be the name of your package<br>// for example: `codegen.macro`)<br>const functionCall = myMacro('Awesome');<br>const jsx = &lt;JSXMacro cool=\"right!?\"&gt;Hi!&lt;/JSXMacro&gt;;<br>const templateLiteral = myMacro`hi ${'there'}`;<br>literallyAnythingWorks(myMacro);</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(myMacro);<br>function myMacro({ references, state, babel }) {<br>  // `state` is the second argument you're passed to a visitor in a<br>  // normal babel plugin. `babel` is the `@babel/core` module.<br>  // do whatever you like to the AST paths you find in `references`.<br>  // open up the console to see what's logged and start playing around!<br>// references.default refers to the default import (`myMacro` above)<br>  // references.JSXMacro refers to the named import of `JSXMacro`<br>  const { JSXMacro = [], default: defaultImport = [] } = references;<br>defaultImport.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"TaggedTemplateExpression\") {<br>      console.log(\"template literal contents\", referencePath.parentPath.get(\"quasi\"));<br>    } else if (referencePath.parentPath.type === \"CallExpression\") {<br>      if (referencePath === referencePath.parentPath.get(\"callee\")) {<br>        console.log(<br>          \"function call arguments (as callee)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      } else if (referencePath.parentPath.get(\"arguments\").includes(referencePath)) {<br>        console.log(<br>          \"function call arguments (as argument)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      }<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>JSXMacro.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"JSXOpeningElement\") {<br>      console.log(\"jsx props\", {<br>        attributes: referencePath.parentPath.get(\"attributes\"),<br>        children: referencePath.parentPath.parentPath.get(\"children\")<br>      });<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>}</pre><p>Next, open up your developer console and check out the console logs. Have fun with that!</p><blockquote>Alternatively, you can just <a href=\"https://astexplorer.net/#/gist/bee085792657d68468353b868a34a2a6/97e09889c85de1f839717a8b351ad4ec1376501a\" target=\"_blank\" rel=\"noopener noreferrer\">go here</a></blockquote><h3>Conclusion</h3><p>I think there are a LOT of really cool places we can go with this technology. I didn‚Äôt spend any time in this newsletter talking about the why behind macros or giving you ideas. I‚Äôll link to some resources for ideas below. The basic idea is if there‚Äôs a way that you can pre-compile some of your operations, then you can improve runtime performance/bundle size of your application. In addition, this allows you to do some things at build time when you have access to the file system. The possibilities are really endless and we‚Äôre just getting started! Enjoy!</p>",
      "isLargePreview": false,
      "imgDescriptor": "1*mJEOJUxW51Vh-Y7cihnS0w.jpeg",
      "date": "Jun 4",
      "readTimeEstimate": "5 min"
    },
    {
      "id": 7,
      "blogId": 1,
      "userId": 1,
      "title": "How I learn an Open Source Codebase",
      "subTitle": "What I do to learn and understand an open source project to which I want to contribute.",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">my newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</strong></p>\n  <p>Participating in open source has been awesome for me. It has made me and the stuff I make better. A common question that I get from folks is how to go about learning an open source codebase and understand other‚Äôs code.<br></p><p>In my blog post <a href=\"https://medium.com/@kentcdodds/open-source-stamina-dafd063f9932\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúOpen Source Stamina‚Äù</a>, I make an important observation:</p><blockquote><b>You contribute best to something you use regularly.</b></blockquote>\n\n  <p>So while it can be a lot of fun to just jump into any open source project and help out. Sustainable contributions are best found in projects that you use on a regular basis. You have a better understanding of the use cases of the code which will help you understand the code better.</p><h3>Some steps</h3>\n  <p>Here‚Äôs a sequence of events I go through when I‚Äôm trying to learn or contribute to an open source project:</p><h4>Contributing Guidelines</h4><p>Look at the contributing guidelines first! This can be found in the <strike>README.md</strike> or a <strike>CONTRIBUTING.md</strike> file in the project. If it doesn‚Äôt exist, then file an issue and ask the maintainer to either make one or give you an idea of what they expect out of contributions.</p><h4>Project setup</h4><p>When you set up the project on your computer, make sure that you first install the dependencies and that the tests pass (if there are any). For JavaScript projects, you can mostly do:</p><ol><li>clone repo<br></li><li><strike>npm install</strike><br></li><li><strike>npm test</strike><br></li></ol><p>If all that works then you‚Äôre ready to go. The last thing you want to do is clone a repo with failing tests, make your change, and think that your change is the reason the tests are failing! This has happened to me :-(</p><h4>Follow the code</h4><p>Next, I try to follow the code in my head starting at the entry point where I‚Äôm interested in (like a function call, or a CLI with a certain argument). This can be intimidating for bigger projects, but it‚Äôs not as bad as you might think.</p><p>In my blogpost <a href=\"https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúWhat open source project should I contribute to?‚Äù</a> I talk a little bit about how to find where the code is for a specific API.</p><h4>Break things</h4><p>Reading and running the tests is also useful. Breaking things can also be a helpful way to learn a codebase.</p><h4>Log and step through</h4><p>It‚Äôs a tried and true debugging mechanism: <strike>console.log</strike> is a great way to learn a codebase. üëç Even better if you can run it in the browser DevTools that‚Äôs also great. <a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\" target=\"_blank\" rel=\"noopener noreferrer\">Read more about NodeJS debugging in Chrome DevTools</a>.</p><p>One other thing you might try is running the project‚Äôs code in the context of your application. I talk about this a fair amount in my blog post from a few weeks ago <a href=\"https://blog.kentcdodds.com/spelunking-in-node-modules-bf165af19968\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúSpelunking in node_modules üë∑‚Äù</a>.</p><h3>Conclusion</h3><p>Something else that I‚Äôve found helpful is to ask someone on the project to walk me through some part of the code. I try to make it worth their time by offering to record our conversation and make it publicly available. This is appealing to maintainers because having material out there for new contributors to watch is very helpful. Here are some examples:</p><ul><li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Why, What, and How of React Fiber with Dan Abramov and Andrew Clark</a><br></li><li><a href=\"https://www.youtube.com/watch?v=dRo_egw7tBc&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a><br></li><li><a href=\"https://www.youtube.com/watch?v=i31VtyJSM-I&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript &amp; React Testing with Jest</a><br></li><li><a href=\"https://www.youtube.com/watch?v=wUpPsEcGsg8&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Contributing to ReactJS</a><br></li></ul><p>I hope this is helpful! Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*NbePWo0hJrYA4mHeQBHmDw.jpeg",
      "date": "May 14",
      "readTimeEstimate": "4 min"
    },
    {
      "id": 8,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it‚Äôs good, why it‚Äôs bad, and how to avoid common problems with it.",
      "contentMarkup": "<p><b>NOTE: This is a cross-post from my <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</b></p><p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as ‚Äúthreading‚Äù), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</pre><p>Let‚Äôs refactor this into two components now:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        The button is {on ? 'on' : 'off'}<br>      &lt;/div&gt;<br>      &lt;button onClick={onToggle}&gt;<br>        Toggle<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre><p>Simple enough, the <strike>Switch</strike> needs a reference to the <strike>toggle</strike> and <strike>on</strike> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;SwitchMessage on={on} /&gt;<br>      &lt;SwitchButton onToggle={onToggle} /&gt;<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchMessage({on}) {<br>  return (<br>    &lt;div&gt;<br>      The button is {on ? 'on' : 'off'}<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchButton({onToggle}) {<br>  return (<br>    &lt;button onClick={onToggle}&gt;<br>      Toggle<br>    &lt;/button&gt;<br>  )<br>}</pre><p>This is prop drilling. To get the <strike>on</strike> state and <strike>toggle</strike> handler to the right places, we have to drill (or thread) props through the <strike>Switch</strike> component. The <strike>Switch</strike> component itself doesn't actually need those values to function, but we have to accept and forward those props because its children need them.</p><h3>Why is prop drilling good?</h3><p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <strike>$scope</strike> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <b>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</b></p><p>One reason we prefer ESModules over global variables is because it allows us to be more explicit about where our values are used, making it much easier to track values and eases the process determining what impact your changes will have on the rest of the application.</p><p>Prop drilling at its most basic level is simply explicitly passing values throughout the view of your application. This is great because if you were coming to the <strike>Toggle</strike> above and decided you want to refactor the <strike>on</strike> state to be an enum, you'd easily be able to track all places it's used by following the code statically (without having to run it) and make that update. The key here is explicitness over implicitness.</p><h3>What problems can prop drilling cause?</h3><p>In our contrived example above, there‚Äôs absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It‚Äôs not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p><ul><li>Refactor the shape of some data (ie: <strike>{user: {name: 'Joe West'}}</strike> -&gt; <strike>{user: {firstName: 'Joe', lastName: 'West'}}</strike>).</li><li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they‚Äôre no longer needed.</li><li>Under-forwarding props + abusing <strike>defaultProps</strike> so you're not made aware of missing props (also due to (re)moving a component).</li><li>Renaming props halfway through (ie <strike>&lt;Toggle on={this.state.on} /&gt;</strike> renders <strike>&lt;Switch toggleIsOn={on} /&gt;</strike>) making keeping track of that in your brain difficult.</li></ul><p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p><h3>How can we avoid problems with prop drilling?</h3><p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!<br></p><blockquote>Fun fact, there‚Äôs nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you‚Äôd have one giant render method‚Ä¶ I am not advocating this though‚Ä¶ Just something to think about :)</blockquote><p>Another thing you can can do to mitigate the effects of prop-drilling is avoid using defaultProps for anything that's a required prop. Using a defaultProp for something that's actually required for the component to function properly is just hiding important errors and making things fail silently. So only use defaultProps for things that are not required.<br></p><p>Keep state as close to where it‚Äôs relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: <a href=\"https://blog.kentcdodds.com/application-state-management-66de608ccb24\" target=\"_blank\" rel=\"noopener noreferrer\">Application State Management</a>.<br></p><p>Use React‚Äôs new Context API for things that are truly necessary deep in the react tree. They don‚Äôt have to be things you need everywhere in the application (you can render a provider anywhere in the app). This can really help avoid some issues with prop drilling. It‚Äôs been noted that context is kinda taking us back to the days of global variables. The difference is that because of the way the API was designed, you can still statically find the source of the context as well as any consumers with relative ease.<br></p><h3>Conclusion</h3><p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 9,
      "blogId": 1,
      "userId": 1,
      "title": "Write your own code transform for fun and profit",
      "subTitle": "How to write your own code macro with babel-plugin-macros üé£",
      "contentMarkup": "<p>If you haven‚Äôt heard, <a href=\"https://github.com/kentcdodds/babel-plugin-macros\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-plugin-macros</strike></a> \"enables zero-config, importable babel plugins.\" A few months ago, I published a blog post about it on the official babel blog: <a href=\"https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros\" target=\"_blank\" rel=\"noopener noreferrer\">\"Zero-config code transformation with babel-plugin-macros\"</a>.<br></p><p>Since then, there have been a few exciting developments:<br></p><ol><li><b>You can use it with a create-react-app application</b> (v2 beta) because it‚Äôs now included by default in the beta version of <a href=\"https://www.npmjs.com/package/babel-preset-react-app\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-preset-react-app</strike></a> (which is what create-react-app v2 beta is using!)<br></li><li>It was added as an optional transform to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a> by <a href=\"https://twitter.com/FWeinb\" target=\"_blank\" rel=\"noopener noreferrer\">@FWeinb</a></li></ol><p>Up until now, only early adopters have tried to write a macro, though there are a fair amount of people using the growing list of <a href=\"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/macros.md\" target=\"_blank\" rel=\"noopener noreferrer\">existing macros</a>. There are tons of awesome things you can do with <strike>babel-plugin-macros</strike>, and I want to dedicate this newsletter to showing you how to get started playing around with writing your own.</p><p>Let‚Äôs start off with a contrived macro that can split a string of text and replace every space with <strike>üê∂</strike>. We'll call it <strike>gemmafy</strike> because my dog's name is \"Gemma.\" Woof!<br></p><ol><li>Go to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a><br></li><li>Make sure the language is set to <strike>JavaScript</strike><br></li><li>Make sure the parser is set to <strike>babylon7</strike><br></li><li>Enable the transform and set it to <strike>babel-macros</strike> (or <strike>babel-plugin-macros</strike> as soon as this is merged)<br></li></ol><p>Then copy/paste this in the source (top left) code panel:<br></p><pre>import gemmafy from 'gemmafy.macro'\n<br>console.log(gemmafy('hello world'))</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(gemmafyMacro)\n<br>function gemmafyMacro({ references, state, babel }) {<br>  references.default.forEach(referencePath =&gt; {<br>    const [firstArgumentPath] = referencePath.parentPath.get('arguments')<br>    const stringValue = firstArgumentPath.node.value<br>    const gemmafied = stringValue.split(' ').join(' üê∂ ')<br>    const gemmafyFunctionCallPath = firstArgumentPath.parentPath<br>    const gemmafiedStringLiteralNode = babel.types.stringLiteral(gemmafied)<br>    gemmafyFunctionCallPath.replaceWith(gemmafiedStringLiteralNode)<br>  })<br>}</pre><blockquote>Alternatively, you can <a href=\"https://astexplorer.net/#/gist/b93bac9c0cdeddd6a1888ad7e82f4cbe/e84e9536951bd0d6fec76b9b50e5f6b01539a4c5\" target=\"_blank\" rel=\"noopener noreferrer\">open this</a></blockquote><p>TADA üéâ! You‚Äôve written your (probably) very first babel plugin via a macro!</p><p>Here‚Äôs the output that you should be seeing (in the bottom right panel):</p><pre>console.log(\"hello üê∂ world\")</pre><p>You‚Äôll notice that <strike>babel-plugin-macros</strike> will take care of removing the import at the top of the file for you, and our macro replaced the <strike>gemmafy</strike> call with the string.</p><p>So here‚Äôs your challenge. Try to add this:<br></p><pre>console.log(gemmafy('hello world', 'world goodbye'))</pre><p>Right now that‚Äôll transpile to:</p><pre>console.log(\"hello üê∂ world\")</pre><p>Your job is to make it do this instead:</p><pre>console.log(\"hello üê∂ world\", \"goodbye üê∂ world\")</pre><p>From there, you can play around with it and do a lot of fun things!</p><p>If you want to see more of the capabilities, then copy this in the source (top left):</p><pre>import myMacro, { JSXMacro } from 'AnyNameThatEndsIn.macro';<br>// (note: in reality, the AnyNameThatEndsIn.macro should be the name of your package<br>// for example: `codegen.macro`)<br>const functionCall = myMacro('Awesome');<br>const jsx = &lt;JSXMacro cool=\"right!?\"&gt;Hi!&lt;/JSXMacro&gt;;<br>const templateLiteral = myMacro`hi ${'there'}`;<br>literallyAnythingWorks(myMacro);</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(myMacro);<br>function myMacro({ references, state, babel }) {<br>  // `state` is the second argument you're passed to a visitor in a<br>  // normal babel plugin. `babel` is the `@babel/core` module.<br>  // do whatever you like to the AST paths you find in `references`.<br>  // open up the console to see what's logged and start playing around!<br>// references.default refers to the default import (`myMacro` above)<br>  // references.JSXMacro refers to the named import of `JSXMacro`<br>  const { JSXMacro = [], default: defaultImport = [] } = references;<br>defaultImport.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"TaggedTemplateExpression\") {<br>      console.log(\"template literal contents\", referencePath.parentPath.get(\"quasi\"));<br>    } else if (referencePath.parentPath.type === \"CallExpression\") {<br>      if (referencePath === referencePath.parentPath.get(\"callee\")) {<br>        console.log(<br>          \"function call arguments (as callee)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      } else if (referencePath.parentPath.get(\"arguments\").includes(referencePath)) {<br>        console.log(<br>          \"function call arguments (as argument)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      }<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>JSXMacro.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"JSXOpeningElement\") {<br>      console.log(\"jsx props\", {<br>        attributes: referencePath.parentPath.get(\"attributes\"),<br>        children: referencePath.parentPath.parentPath.get(\"children\")<br>      });<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>}</pre><p>Next, open up your developer console and check out the console logs. Have fun with that!</p><blockquote>Alternatively, you can just <a href=\"https://astexplorer.net/#/gist/bee085792657d68468353b868a34a2a6/97e09889c85de1f839717a8b351ad4ec1376501a\" target=\"_blank\" rel=\"noopener noreferrer\">go here</a></blockquote><h3>Conclusion</h3><p>I think there are a LOT of really cool places we can go with this technology. I didn‚Äôt spend any time in this newsletter talking about the why behind macros or giving you ideas. I‚Äôll link to some resources for ideas below. The basic idea is if there‚Äôs a way that you can pre-compile some of your operations, then you can improve runtime performance/bundle size of your application. In addition, this allows you to do some things at build time when you have access to the file system. The possibilities are really endless and we‚Äôre just getting started! Enjoy!</p>",
      "isLargePreview": false,
      "imgDescriptor": "1*mJEOJUxW51Vh-Y7cihnS0w.jpeg",
      "date": "Jun 4",
      "readTimeEstimate": "5 min"
    },
    {
      "id": 10,
      "blogId": 1,
      "userId": 1,
      "title": "How I learn an Open Source Codebase",
      "subTitle": "What I do to learn and understand an open source project to which I want to contribute.",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">my newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</strong></p>\n  <p>Participating in open source has been awesome for me. It has made me and the stuff I make better. A common question that I get from folks is how to go about learning an open source codebase and understand other‚Äôs code.<br></p><p>In my blog post <a href=\"https://medium.com/@kentcdodds/open-source-stamina-dafd063f9932\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúOpen Source Stamina‚Äù</a>, I make an important observation:</p><blockquote><b>You contribute best to something you use regularly.</b></blockquote>\n\n  <p>So while it can be a lot of fun to just jump into any open source project and help out. Sustainable contributions are best found in projects that you use on a regular basis. You have a better understanding of the use cases of the code which will help you understand the code better.</p><h3>Some steps</h3>\n  <p>Here‚Äôs a sequence of events I go through when I‚Äôm trying to learn or contribute to an open source project:</p><h4>Contributing Guidelines</h4><p>Look at the contributing guidelines first! This can be found in the <strike>README.md</strike> or a <strike>CONTRIBUTING.md</strike> file in the project. If it doesn‚Äôt exist, then file an issue and ask the maintainer to either make one or give you an idea of what they expect out of contributions.</p><h4>Project setup</h4><p>When you set up the project on your computer, make sure that you first install the dependencies and that the tests pass (if there are any). For JavaScript projects, you can mostly do:</p><ol><li>clone repo<br></li><li><strike>npm install</strike><br></li><li><strike>npm test</strike><br></li></ol><p>If all that works then you‚Äôre ready to go. The last thing you want to do is clone a repo with failing tests, make your change, and think that your change is the reason the tests are failing! This has happened to me :-(</p><h4>Follow the code</h4><p>Next, I try to follow the code in my head starting at the entry point where I‚Äôm interested in (like a function call, or a CLI with a certain argument). This can be intimidating for bigger projects, but it‚Äôs not as bad as you might think.</p><p>In my blogpost <a href=\"https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúWhat open source project should I contribute to?‚Äù</a> I talk a little bit about how to find where the code is for a specific API.</p><h4>Break things</h4><p>Reading and running the tests is also useful. Breaking things can also be a helpful way to learn a codebase.</p><h4>Log and step through</h4><p>It‚Äôs a tried and true debugging mechanism: <strike>console.log</strike> is a great way to learn a codebase. üëç Even better if you can run it in the browser DevTools that‚Äôs also great. <a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\" target=\"_blank\" rel=\"noopener noreferrer\">Read more about NodeJS debugging in Chrome DevTools</a>.</p><p>One other thing you might try is running the project‚Äôs code in the context of your application. I talk about this a fair amount in my blog post from a few weeks ago <a href=\"https://blog.kentcdodds.com/spelunking-in-node-modules-bf165af19968\" target=\"_blank\" rel=\"noopener noreferrer\">‚ÄúSpelunking in node_modules üë∑‚Äù</a>.</p><h3>Conclusion</h3><p>Something else that I‚Äôve found helpful is to ask someone on the project to walk me through some part of the code. I try to make it worth their time by offering to record our conversation and make it publicly available. This is appealing to maintainers because having material out there for new contributors to watch is very helpful. Here are some examples:</p><ul><li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Why, What, and How of React Fiber with Dan Abramov and Andrew Clark</a><br></li><li><a href=\"https://www.youtube.com/watch?v=dRo_egw7tBc&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a><br></li><li><a href=\"https://www.youtube.com/watch?v=i31VtyJSM-I&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript &amp; React Testing with Jest</a><br></li><li><a href=\"https://www.youtube.com/watch?v=wUpPsEcGsg8&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Contributing to ReactJS</a><br></li></ul><p>I hope this is helpful! Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*NbePWo0hJrYA4mHeQBHmDw.jpeg",
      "date": "May 14",
      "readTimeEstimate": "4 min"
    }
  ],
  "revokedTokens": [
    {
      "id": "uuid - string",
      "token": "jwt - string"
    }
  ]
}