{
  "users": [
    {
      "id": 1,
      "fullName": "Kent C. Dodds",
      "avatarUrl": "https://cdn-images-1.medium.com/fit/c/120/120/1*9ZtET_L1852yXaDZJUo9CQ.png",
      "bio": "Making software development more accessible ¬∑ Husband, Father, Mormon, Teacher, OSS, GDE, @TC39 ¬∑ @PayPalEng @eggheadio @FrontendMasters @JavaScriptAir ¬∑ #JS"
    }
  ],
  "blogs": [
    {
      "id": 1,
      "userId": 1,
      "name": "Kent C. Dodds",
      "description": "Let‚Äôs make awesome with JavaScript (Photo by Luca Bravo on Unsplash)"
    }
  ],
  "posts": [
    {
      "id": 1,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it‚Äôs good, why it‚Äôs bad, and how to avoid common problems with it.",
      "contentMarkup": "<p><b>NOTE: This is a cross-post from my <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</b></p><p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as ‚Äúthreading‚Äù), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</pre><p>Let‚Äôs refactor this into two components now:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        The button is {on ? 'on' : 'off'}<br>      &lt;/div&gt;<br>      &lt;button onClick={onToggle}&gt;<br>        Toggle<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre><p>Simple enough, the <strike>Switch</strike> needs a reference to the <strike>toggle</strike> and <strike>on</strike> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;SwitchMessage on={on} /&gt;<br>      &lt;SwitchButton onToggle={onToggle} /&gt;<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchMessage({on}) {<br>  return (<br>    &lt;div&gt;<br>      The button is {on ? 'on' : 'off'}<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchButton({onToggle}) {<br>  return (<br>    &lt;button onClick={onToggle}&gt;<br>      Toggle<br>    &lt;/button&gt;<br>  )<br>}</pre><p>This is prop drilling. To get the <strike>on</strike> state and <strike>toggle</strike> handler to the right places, we have to drill (or thread) props through the <strike>Switch</strike> component. The <strike>Switch</strike> component itself doesn't actually need those values to function, but we have to accept and forward those props because its children need them.</p><h3>Why is prop drilling good?</h3><p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <strike>$scope</strike> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <b>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</b></p><p>One reason we prefer ESModules over global variables is because it allows us to be more explicit about where our values are used, making it much easier to track values and eases the process determining what impact your changes will have on the rest of the application.</p><p>Prop drilling at its most basic level is simply explicitly passing values throughout the view of your application. This is great because if you were coming to the <strike>Toggle</strike> above and decided you want to refactor the <strike>on</strike> state to be an enum, you'd easily be able to track all places it's used by following the code statically (without having to run it) and make that update. The key here is explicitness over implicitness.</p><h3>What problems can prop drilling cause?</h3><p>In our contrived example above, there‚Äôs absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It‚Äôs not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p><ul><li>Refactor the shape of some data (ie: <strike>{user: {name: 'Joe West'}}</strike> -&gt; <strike>{user: {firstName: 'Joe', lastName: 'West'}}</strike>).</li><li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they‚Äôre no longer needed.</li><li>Under-forwarding props + abusing <strike>defaultProps</strike> so you're not made aware of missing props (also due to (re)moving a component).</li><li>Renaming props halfway through (ie <strike>&lt;Toggle on={this.state.on} /&gt;</strike> renders <strike>&lt;Switch toggleIsOn={on} /&gt;</strike>) making keeping track of that in your brain difficult.</li></ul><p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p><h3>How can we avoid problems with prop drilling?</h3><p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!<br></p><blockquote>Fun fact, there‚Äôs nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you‚Äôd have one giant render method‚Ä¶ I am not advocating this though‚Ä¶ Just something to think about :)</blockquote><p>Another thing you can can do to mitigate the effects of prop-drilling is avoid using defaultProps for anything that's a required prop. Using a defaultProp for something that's actually required for the component to function properly is just hiding important errors and making things fail silently. So only use defaultProps for things that are not required.<br></p><p>Keep state as close to where it‚Äôs relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: <a href=\"https://blog.kentcdodds.com/application-state-management-66de608ccb24\" target=\"_blank\" rel=\"noopener noreferrer\">Application State Management</a>.<br></p><p>Use React‚Äôs new Context API for things that are truly necessary deep in the react tree. They don‚Äôt have to be things you need everywhere in the application (you can render a provider anywhere in the app). This can really help avoid some issues with prop drilling. It‚Äôs been noted that context is kinda taking us back to the days of global variables. The difference is that because of the way the API was designed, you can still statically find the source of the context as well as any consumers with relative ease.<br></p><h3>Conclusion</h3><p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!<br></p>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 2,
      "blogId": 1,
      "userId": 1,
      "title": "üíØ UPDATED: Advanced React Component Patterns ‚öõÔ∏è",
      "subTitle": "Now featuring the latest React APIs (like context) and entirely new patterns (like state reducer props).",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"#\">my newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</strong></p>\n  <p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as ‚Äúthreading‚Äù), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p>\n\n  <h3>What is prop drilling?</h3>\n  <p>Prop drilling (also called ‚Äúthreading‚Äù) refers to the process you have to go through to get data to parts of the React Component tree. Let‚Äôs look at a very simple example of a stateful component (yes, it‚Äôs my favorite component example):</p>\n  <pre><code>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</code></pre>\n  <p>Simple enough, the <code>Switch</code> needs a reference to the <code>toggle</code> and <code>on</code> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p>\n\n  <h3>Why is prop drilling good?</h3>\n  <p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <code>$scope</code> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <strong>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</strong></p>\n\n  <h3>What problems can prop drilling cause?</h3>\n  <p>In our contrived example above, there‚Äôs absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It‚Äôs not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p>\n  <ul>\n    <li>Refactor the shape of some data (ie: <code class=\"markup--code markup--li-code\">{user: {name: 'Joe West'}}</code> -&gt; <code class=\"markup--code markup--li-code\">{user: {firstName: 'Joe', lastName: 'West'}}</code>)</li>\n    <li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they‚Äôre no longer needed.</li>\n    <li>Under-forwarding props + abusing <code classname=\"markup--code markup--li-code\">defaultProps</code> so you're not made aware of missing props (also due to (re)moving a component).</li>\n    <li>Renaming props halfway through (ie <code classname=\"markup--code markup--li-code\">&lt;Toggle on={this.state.on} /&gt;</code> renders <code classname=\"markup--code markup--li-code\">&lt;Switch toggleIsOn={on} /&gt;</code>) making keeping track of that in your brain difficult.</li>\n  </ul>\n  <p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p>\n\n  <h3>How can we avoid problems with prop drilling?</h3>\n  <p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!</p>\n  <blockquote>Fun fact, there‚Äôs nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you‚Äôd have one giant render method‚Ä¶ I am not advocating this though‚Ä¶ Just something to think about&nbsp;:)</blockquote>\n  <p>Keep state as close to where it‚Äôs relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: Application State Management.</p>\n\n  <h4>Compound Components + Context API = ‚ù§Ô∏è</h4>\n  <p>In particular, the Context API makes compound components much easier to make more flexible.</p>\n\n  <h3>Conclusion</h3>\n  <p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!</p>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*ufuznjwWN4gP4S-jp2MOww.png",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*ufuznjwWN4gP4S-jp2MOww.png",
      "date": "Jun 1",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 3,
      "blogId": 1,
      "userId": 1,
      "title": "‚ú® Free Frontend Masters Courses ‚öõÔ∏è for a Week üéâ",
      "subTitle": "My Advanced Component Patterns and Testing React Applications are free on Frontend Masters for a limited time!",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"#\">my newsletter</a>. I publish each email two weeks after it‚Äôs sent. Subscribe to get more content like this earlier right in your inbox! üíå</strong></p>\n  <p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as ‚Äúthreading‚Äù), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p>\n\n  <h3>What is prop drilling?</h3>\n  <p>Prop drilling (also called ‚Äúthreading‚Äù) refers to the process you have to go through to get data to parts of the React Component tree. Let‚Äôs look at a very simple example of a stateful component (yes, it‚Äôs my favorite component example):</p>\n  <pre><code>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</code></pre>\n  <p>Simple enough, the <code>Switch</code> needs a reference to the <code>toggle</code> and <code>on</code> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p>\n\n  <h3>Why is prop drilling good?</h3>\n  <p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <code>$scope</code> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <strong>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</strong></p>\n\n  <h3>What problems can prop drilling cause?</h3>\n  <p>In our contrived example above, there‚Äôs absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It‚Äôs not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p>\n  <ul>\n    <li>Refactor the shape of some data (ie: <code class=\"markup--code markup--li-code\">{user: {name: 'Joe West'}}</code> -&gt; <code class=\"markup--code markup--li-code\">{user: {firstName: 'Joe', lastName: 'West'}}</code>)</li>\n    <li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they‚Äôre no longer needed.</li>\n    <li>Under-forwarding props + abusing <code classname=\"markup--code markup--li-code\">defaultProps</code> so you're not made aware of missing props (also due to (re)moving a component).</li>\n    <li>Renaming props halfway through (ie <code classname=\"markup--code markup--li-code\">&lt;Toggle on={this.state.on} /&gt;</code> renders <code classname=\"markup--code markup--li-code\">&lt;Switch toggleIsOn={on} /&gt;</code>) making keeping track of that in your brain difficult.</li>\n  </ul>\n  <p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p>\n\n  <h3>How can we avoid problems with prop drilling?</h3>\n  <p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!</p>\n  <blockquote>Fun fact, there‚Äôs nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you‚Äôd have one giant render method‚Ä¶ I am not advocating this though‚Ä¶ Just something to think about&nbsp;:)</blockquote>\n  <p>Keep state as close to where it‚Äôs relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: Application State Management.</p>\n\n  <h4>Compound Components + Context API = ‚ù§Ô∏è</h4>\n  <p>In particular, the Context API makes compound components much easier to make more flexible.</p>\n\n  <h3>Conclusion</h3>\n  <p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!</p>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*iehP0UAWCqSzQ0CxhQcNrA.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*iehP0UAWCqSzQ0CxhQcNrA.jpeg",
      "date": "May 18",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 4,
      "blogId": 1,
      "userId": 1,
      "title": "When to use Control Props or State Reducers",
      "subTitle": "Comparing two similar patterns that enable many of the same use cases.",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": true,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*-rTkIBSzA1xVqPeuttf4kw.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*-rTkIBSzA1xVqPeuttf4kw.jpeg",
      "date": "Jun 11",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 5,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it‚Äôs good, why it‚Äôs bad, and how to avoid common problems with it.",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 6,
      "blogId": 1,
      "userId": 1,
      "title": "üíØ UPDATED: Advanced React Component Patterns ‚öõÔ∏è",
      "subTitle": "Now featuring the latest React APIs (like context) and entirely new patterns (like state reducer props).",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*ufuznjwWN4gP4S-jp2MOww.png",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*ufuznjwWN4gP4S-jp2MOww.png",
      "date": "Jun 1",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 7,
      "blogId": 1,
      "userId": 1,
      "title": "‚ú® Free Frontend Masters Courses ‚öõÔ∏è for a Week üéâ",
      "subTitle": "My Advanced Component Patterns and Testing React Applications are free on Frontend Masters for a limited time!",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*iehP0UAWCqSzQ0CxhQcNrA.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*iehP0UAWCqSzQ0CxhQcNrA.jpeg",
      "date": "May 18",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 8,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it‚Äôs good, why it‚Äôs bad, and how to avoid common problems with it.",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 9,
      "blogId": 1,
      "userId": 1,
      "title": "üíØ UPDATED: Advanced React Component Patterns ‚öõÔ∏è",
      "subTitle": "Now featuring the latest React APIs (like context) and entirely new patterns (like state reducer props).",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*ufuznjwWN4gP4S-jp2MOww.png",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*ufuznjwWN4gP4S-jp2MOww.png",
      "date": "Jun 1",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 10,
      "blogId": 1,
      "userId": 1,
      "title": "‚ú® Free Frontend Masters Courses ‚öõÔ∏è for a Week üéâ",
      "subTitle": "My Advanced Component Patterns and Testing React Applications are free on Frontend Masters for a limited time!",
      "contentMarkup": "<h1>post body markup</h1>",
      "isLargePreview": false,
      "previewImgUrl": "https://cdn-images-1.medium.com/max/1000/1*iehP0UAWCqSzQ0CxhQcNrA.jpeg",
      "fullsizeImgUrl": "https://cdn-images-1.medium.com/max/2000/1*iehP0UAWCqSzQ0CxhQcNrA.jpeg",
      "date": "May 18",
      "readTimeEstimate": "6 min"
    }
  ]
}